<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wangqingyang-blog</title>
  
  <subtitle>myBlog</subtitle>
  <link href="https://wang-qing-yang.github.io/atom.xml" rel="self"/>
  
  <link href="https://wang-qing-yang.github.io/"/>
  <updated>2023-04-09T15:54:59.185Z</updated>
  <id>https://wang-qing-yang.github.io/</id>
  
  <author>
    <name>wangqingyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring6-day1</title>
    <link href="https://wang-qing-yang.github.io/2023/04/09/Spring6-day1/"/>
    <id>https://wang-qing-yang.github.io/2023/04/09/Spring6-day1/</id>
    <published>2023-04-09T15:49:05.000Z</published>
    <updated>2023-04-09T15:54:59.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring6"><a href="#Spring6" class="headerlink" title="Spring6"></a>Spring6</h2><h3 id="问题与解决方法"><a href="#问题与解决方法" class="headerlink" title="问题与解决方法"></a>问题与解决方法</h3><h4 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h4><p>web层（表示层），service层（业务层），dao（持久层）</p><img src="C:\Users\wang\AppData\Roaming\Typora\typora-user-images\image-20230409222335855.png" alt="image-20230409222335855" style="zoom:50%;" /><h4 id="简单依赖关系"><a href="#简单依赖关系" class="headerlink" title="简单依赖关系"></a>简单依赖关系</h4><p>在service层，web层的实例中，先创建dao层的实例，再在方法中调用实例方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//用于调用DAO层，即持久层进行具体操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImplForMySQL</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//删除用户信息的逻辑</span></span><br><span class="line">        <span class="comment">//调用持久层</span></span><br><span class="line">        userDao.deleteById();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则当持久层的实现类进行变换，需要在业务层修改代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于调用DAO层，即持久层进行具体操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImplForOracle</span>();</span><br></pre></td></tr></table></figure><p>同样当业务层的实现类进行变换，需要在表现层修改相应的创建实例的代码</p><p>导致<strong>程序耦合高</strong>，因为在层中创建下层的实例，导致上层依赖下层。</p><h5 id="OCP开闭原则"><a href="#OCP开闭原则" class="headerlink" title="OCP开闭原则"></a>OCP开闭原则</h5><p>不符合<strong>OCP开闭原则</strong>：软件开发中应当<strong>对扩展开放，对修改关闭</strong>。因为修改之前正常的程序，则需要对<strong>各个修改的部分进行重新测试上线</strong>，成本高，复杂度高。</p><p>（软件七大开发原则，其他六原则为OCP服务）</p><h5 id="依赖倒置原则（DIP原则）"><a href="#依赖倒置原则（DIP原则）" class="headerlink" title="依赖倒置原则（DIP原则）"></a>依赖倒置原则（DIP原则）</h5><p>Dependence Inversion principle，<strong>面向抽象编程，面向接口编程，上层不依赖下层</strong></p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//依赖倒置</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao；</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不再是具体的实现类</span></span><br><span class="line">        userDao.deleteById();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如何创建对象？如何将对象赋值到UserDao</span></span><br></pre></td></tr></table></figure><h5 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h5><p>Spring框架，帮助创建对象，维护对象之间关系（即怎样选择实例），并对象赋到属性中。将创建对象，new对象，即实例化的工作交给spring做，称为<strong>控制反转（Inversion of Control）</strong>。</p><p><strong>IoC：面向对象编程的一种设计思想，将对象的创建权交出去，将对象与对象之间关系的管理权交出去，由第三方容器负责创建与维护。</strong></p><p>实现方式：<strong>依赖注入（Dependency Injection, DI）</strong></p><p>DI实现方式：set方法注入&#x2F;构造方法注入—–方法中给属性赋值</p><p><strong>Spring框架：一个实现了IoC思想的框架</strong></p><h3 id="Spring概要"><a href="#Spring概要" class="headerlink" title="Spring概要"></a>Spring概要</h3><p>Spring是一个轻量级的<strong>控制反转(IoC)<strong>和</strong>面向切面(AOP)<strong>的</strong>容器框架</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21376908/1663726169861-b5acb757-17e0-4d3d-a811-400eb7edd1b3.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_29,text_5Yqo5Yqb6IqC54K5,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring6&quot;&gt;&lt;a href=&quot;#Spring6&quot; class=&quot;headerlink&quot; title=&quot;Spring6&quot;&gt;&lt;/a&gt;Spring6&lt;/h2&gt;&lt;h3 id=&quot;问题与解决方法&quot;&gt;&lt;a href=&quot;#问题与解决方法&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Spring6" scheme="https://wang-qing-yang.github.io/categories/Spring6/"/>
    
    
    <category term="OCP" scheme="https://wang-qing-yang.github.io/tags/OCP/"/>
    
    <category term="DIP" scheme="https://wang-qing-yang.github.io/tags/DIP/"/>
    
    <category term="IoC" scheme="https://wang-qing-yang.github.io/tags/IoC/"/>
    
    <category term="DI" scheme="https://wang-qing-yang.github.io/tags/DI/"/>
    
    <category term="AOP" scheme="https://wang-qing-yang.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>resemu</title>
    <link href="https://wang-qing-yang.github.io/2023/04/08/resemu/"/>
    <id>https://wang-qing-yang.github.io/2023/04/08/resemu/</id>
    <published>2023-04-08T08:26:59.000Z</published>
    <updated>2023-04-08T08:29:07.838Z</updated>
    
    <content type="html"><![CDATA[ <center>     <h1>王庆阳</h1>     <div>         电话：13696566641 |             邮箱：qywang2021@163.com |        博客：https://wangqingyang.github.io     </div>     <div>         年龄：23 |          性别：男      </div>     <div>         求职意向：后端开发工程师     </div></center><h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><p>2022.09 - 2025.06                          东南大学 控制科学与工程专业                             硕士  </p><p>2018.09 - 2022.06                          合肥工业大学大学 自动化专业                             本科        </p><h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><ul><li>熟练掌握 Java语言，熟悉多线程、集合框架、JVM等相关知识；</li><li>熟练使用Spring Cloud、Spring Boot、MyBatis等常用框架，熟悉Spring IOC、AOP原理，了解Nacos、Spring Cloud  Gateway等组件；</li><li>熟练使用MySQL，熟悉MySQL索引、事务、锁机制、日志系统、数据备份与恢复；</li><li>深入理解Redis数据类型使用场景和内部实现，熟悉持久化和淘汰策略，熟悉缓存高并发场景；</li><li>了解Kafka、Elasticsearch的使用，熟悉Kafka基本结构、消费者组、备份机制的原理，熟悉 Elasticsearch倒排索引的原理。</li></ul><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><p><strong>2019.10 - 2020.01</strong>                        <strong>社区论坛</strong>                               <strong>全栈开发工程师</strong></p><p><strong>项目简介：</strong> 该论坛是一个互动交流平台，实现了注册登录、发帖评论、回复点赞、消息提醒、内容搜索和网站数据统计的功能，并将用户头像等信息存于七牛云。</p><p><strong>项目地址：</strong>演示地址: <a href="http://www.coolsen.cn/">www.coolsen.cn</a>     Github: <a href="https://github.com/cosen1024/community">https://github.com/cosen1024/community</a></p><p><strong>技术栈：</strong>Spring Boot + MyBatis + MySQL + Redis + Kafka + Elasticsearch</p><p><strong>工作内容：</strong></p><ul><li>使用Redis存储登录ticket和验证码，解决分布式session问题；</li><li>使用Redis的set实现点赞，zset实现关注，HyperLogLog统计UV，Bitmap统计DAU；</li><li>使用Kafka处理发送评论、点赞和关注等系统通知，起到解耦和异步调用的作用；</li><li>使用Elasticsearch对帖子搜索功能进行重构，通过IK中文分词器增加增量索引和全局索引，实现搜索关键词高亮显示等功能；</li><li>对热帖排行模块，使用分布式缓存Redis和本地缓存Caffeine作为多级缓存，将QPS提升了20倍（10-200），大大提升了网站访问速度，并使用Quartz定时更新热帖排行榜。</li></ul><h2 id="个人荣誉"><a href="#个人荣誉" class="headerlink" title="个人荣誉"></a>个人荣誉</h2>]]></content>
    
    
      
      
    <summary type="html"> &lt;center&gt;
     &lt;h1&gt;王庆阳&lt;/h1&gt;
     &lt;div&gt;
         电话：13696566641 | 
            邮箱：qywang2021@163.com |
        博客：https://wangqingyang.github</summary>
      
    
    
    
    <category term="个人" scheme="https://wang-qing-yang.github.io/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
    <category term="简历" scheme="https://wang-qing-yang.github.io/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>二叉树-1</title>
    <link href="https://wang-qing-yang.github.io/2023/04/08/%E4%BA%8C%E5%8F%89%E6%A0%91-1/"/>
    <id>https://wang-qing-yang.github.io/2023/04/08/%E4%BA%8C%E5%8F%89%E6%A0%91-1/</id>
    <published>2023-04-08T02:30:31.000Z</published>
    <updated>2023-04-08T07:56:08.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    </span><br><span class="line">    TreeNode()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode(<span class="type">int</span> val)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>​二叉树遍历，即按照某种方式，依照某种顺序访问二叉树的<strong>所有节点</strong>，可以理解为<strong>对二叉树的各个子树进行遍历，子树与节点的概念在大多数情况下是相同的，因为每个节点都可以当作一个子树，或者说取得一个节点，则可以获得这个节点为根节点的子树</strong></p><h5 id="遍历目的"><a href="#遍历目的" class="headerlink" title="遍历目的"></a>遍历目的</h5><p>对二叉树的各个节点的访问，能够全面的分析二叉树，因为二叉树<strong>由且仅由</strong>一个个节点组成</p><ol><li>二叉树的结构，具体有：<ul><li>判断二叉树结构特性</li><li>修改二叉树结构，重构二叉树</li></ul></li><li>二叉树的属性<ul><li>取出符合条件的节点（节点个数&#x2F;左叶子之和&#x2F;数左下角的值</li><li>比较各个节点</li></ul></li><li>二叉搜索树属性</li><li>二叉树公共祖先</li><li>二叉搜索树结构</li></ol><h5 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h5><p><strong>二叉树遍历&#x3D;遍历节点&#x3D;遍历子树</strong></p><p>按照遍历方法有：递归遍历与迭代遍历</p><p>按照遍历顺序有：前序遍历，中序遍历，后序遍历，层序遍历</p><p>DFS(深度优先遍历)：前序遍历，中序遍历，后序遍历</p><p>BFS(广度优先遍历)：层序遍历</p><h6 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h6><p>递归写法：</p><ol><li>确定递归函数的参数与返回值：参数往往是节点，返回值往往是题干所需值</li><li>确定终止条件，递归实际上是利用系统栈存储节点信息，需要终止条件防止栈溢出(stack overflow)，终止条件往往是null节点，或者叶子节点，返回相应的返回值</li><li>确定单层递归逻辑，确定每次递归中对节点&#x2F;节点左子树&#x2F;节点右子树的处理顺序，以及对节点的具体操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历，中-&gt;左-&gt;右，即先取出根节点，再遍历左子树，最后遍历右子树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preOrder(list,root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归，输入参数为节点，集合，不需要返回值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(List&lt;Integer&gt; list, TreeNode node)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件，当节点为null，此时不存在节点，则不需要加入集合，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单层逻辑，前序遍历，先将节点值放入集合，再遍历左右子树</span></span><br><span class="line">        list.add(node.val);</span><br><span class="line">        preOrder(list,node.left);</span><br><span class="line">        preOrder(list,node.right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历，左-&gt;中-&gt;右，即先遍历左子树，再取出根节点，最后遍历右子树</span></span><br><span class="line"><span class="comment">//需要注意的是：第一个取出的节点仍为根节点，但是最左侧子树的根节点，正如前面所说，节点即为子树</span></span><br><span class="line"><span class="comment">//即为左叶子节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(List&lt;Integer&gt; list, TreeNode node)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件，当节点为null，此时不存在节点，则不需要加入集合，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单层逻辑，中序遍历，先遍历左子树，再取出根节点，最后遍历右子树</span></span><br><span class="line">        preOrder(list,node.left);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        preOrder(list,node.right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历，左-&gt;右-&gt;中，即先遍历左子树，再遍历右子树，最后取出根节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(List&lt;Integer&gt; list, TreeNode node)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件，当节点为null，此时不存在节点，则不需要加入集合，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单层逻辑，中序遍历，先遍历左子树，再遍历右子树，最后取出根节点</span></span><br><span class="line">        preOrder(list,node.left);</span><br><span class="line">        preOrder(list,node.right);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>层序遍历具有特殊性，利用先进先出的队列模拟系统栈，将每一层的节点加入栈进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//层序遍历，使用先进先出的队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//先将第一层，即根节点加入</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            que.offer(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行层序遍历</span></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//记录当前层的节点个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="comment">//存放当前层的节点</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//遍历层中节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                <span class="comment">//加入下一层到队列</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前层节点加入集合</span></span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h6><p>迭代，则需要创建stack模拟系统栈，栈为先进后出，则<strong>控制入栈顺序就可以确定出栈顺序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序迭代，遍历顺序为中左右，则入栈顺序为右左</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//迭代法，则用栈模拟递归的系统栈</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//先加入根节点到栈</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//先加入右节点，再加入左节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序迭代，即左右中，反转即为中右左，则进行中右左遍历，最后反转即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            <span class="comment">//入栈为左右</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序迭代，左中右，比较特殊，因为访问节点的顺序与处理元素顺序不同</span></span><br><span class="line"><span class="comment">//需要注意：最左叶子节点=最左子树根节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//当当前节点为null，且栈空，则此时已经遍历完全</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//递归加入节点到栈，直到最左叶子节点，即最左子树的根节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//节点为空，则栈顶元素为最左子树根节点，弹出并判断其右子树</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="莫里斯遍历"><a href="#莫里斯遍历" class="headerlink" title="莫里斯遍历"></a>莫里斯遍历</h6><p>​没有辅助空间，改变了树的结构</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>遍历方式中，递归与迭代实现效果相同，仅在代码层面不同，优先选择递归，所有可选的遍历方式实际上仅有：<strong>前序&#x2F;中序&#x2F;后序递归&#x2F;层序遍历</strong></p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210219190809451.png" alt="二叉树大纲"></p><p>按照遍历目的进行分类：</p><h5 id="二叉树属性：取出符合条件的节点"><a href="#二叉树属性：取出符合条件的节点" class="headerlink" title="二叉树属性：取出符合条件的节点"></a>二叉树属性：取出符合条件的节点</h5><ol><li>分析条件，确定判断方式</li><li>选择遍历方式</li></ol><h6 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h6><p>题干：给定二叉树的根节点 root ，返回所有左叶子之和。</p><ul><li>明确条件，左叶子的判断：通过单个节点无法判断其是否为左叶子，需要通过父节点判断，具体判断为</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp;root.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">//root.left为符合条件的左叶子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>选择遍历方式，即对每个子树取得左叶子节点，进行累加，选择任何遍历方式都可以，此处选择后序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历每棵子树，累加左叶子结点值</span></span><br><span class="line">        <span class="comment">//终止条件，当为null，则返回0</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断左节点是否为左叶子</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            mid = root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mid + left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h6><p>题干：找最底层最左边节点的值</p><ul><li>明确条件，最底层最左边的值，即层数最大的叶子节点，即遍历中遇到层数最大的第一个节点</li><li>BFS&#x2F;DFS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，每一层的一个节点，即队列中的第一个元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//层序遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="comment">//初始化结果为根节点值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> root.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="comment">//每层第一个元素即为最左节点</span></span><br><span class="line">            res = que.peek().val;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DFS，深度优先遍历，每次优先遍历当前节点左子树，则当第一次搜索到最大深度，即为最左节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//全局遍历，记录节点值与深度</span></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="type">int</span> maxDepth;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        getLeft(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getLeft</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次遇到深度&gt;，则存储节点</span></span><br><span class="line">        <span class="keyword">if</span>(depth &gt; maxDepth)&#123;</span><br><span class="line">            res = node.val;</span><br><span class="line">            maxDepth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右遍历</span></span><br><span class="line">        getLeft(node.left,depth+<span class="number">1</span>);</span><br><span class="line">        getLeft(node.right,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h6><p>判断树中是否存在根节点到叶子节点的路径和&#x3D;目标值</p><ul><li>不需要遍历整棵树，需要有返回值</li><li>遍历需要存储路径和，即参数为节点与路径和</li></ul><h6 id="113-路径总和2"><a href="#113-路径总和2" class="headerlink" title="113.路径总和2"></a>113.路径总和2</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;f</summary>
      
    
    
    
    <category term="Leetcode" scheme="https://wang-qing-yang.github.io/categories/Leetcode/"/>
    
    
    <category term="二叉树" scheme="https://wang-qing-yang.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
