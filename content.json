{"meta":{"title":"wangqingyang-blog","subtitle":"myBlog","description":"daily recordings","author":"wangqingyang","url":"https://wang-qing-yang.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-04-08T07:32:44.299Z","updated":"2023-04-08T06:55:52.720Z","comments":false,"path":"/404.html","permalink":"https://wang-qing-yang.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-04-08T07:57:50.639Z","updated":"2023-04-08T06:55:52.722Z","comments":false,"path":"about/index.html","permalink":"https://wang-qing-yang.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2023-04-08T06:55:52.723Z","updated":"2023-04-08T06:55:52.723Z","comments":false,"path":"books/index.html","permalink":"https://wang-qing-yang.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-04-08T06:55:52.725Z","updated":"2023-04-08T06:55:52.725Z","comments":false,"path":"tags/index.html","permalink":"https://wang-qing-yang.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-04-08T07:32:54.749Z","updated":"2023-04-08T06:55:52.723Z","comments":false,"path":"categories/index.html","permalink":"https://wang-qing-yang.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"spring在项目中的用法","slug":"spring在项目中的用法","date":"2023-05-18T11:49:25.000Z","updated":"2023-05-18T12:27:07.131Z","comments":true,"path":"2023/05/18/spring在项目中的用法/","link":"","permalink":"https://wang-qing-yang.github.io/2023/05/18/spring%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"SpringIOC(Inversion of Control)控制反转，面向对象编程的一种设计思想，降低代码耦合，符合依赖倒置原则。指将对象的创建和管理交给第三方容器负责，即交给Spring容器 DI(Dependency Injection)依赖注入，实现IOC的方式 使用场景项目结构 controller：控制层，用于与外界交互，请求和响应控制，调用service service：业务层，实现具体的业务，调用dao层，提供接口给controller调用 dao：持久层，操作数据库，提供接口给service调用 配置类，spring容器1234567891011@RunWith(SpringRunner.class)@SpringBootTest@ContextConfiguration(classes = CommunityApplication.class)class CommunityApplicationTests implements ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; 注解方式加入spring容器管理对于自己编写的dao相关类，通过注解方式，统一交给spring容器管理@Repository，默认bean的名字为类名首字母小写，即alphaDaoHibernateImpl，也可以填写在@Repository(“name”) 12345678@Repository(&quot;name&quot;)public class AlphaDaoHibernateImpl implements AlphaDao&#123; @Override public String select() &#123; return &quot;hibernate&quot;; &#125;&#125; 对于service&#x2F;controller同样有@Service&#x2F;@Controller，底层都是@Component 注解形式实现各层调用123@Autowired@Qualifier(&quot;name&quot;)private AlphaDao alphaDao; 注入dao到service，注入service到controller @Autowired注入bean到属性，默认根据类型注入，可以设置@Qualifier(“name”)根据名字注入，相同接口的bean可以通过@Primary设置优先级 也可以通过getBean()获得bean 1AlphaService bean = applicationContext.getBean(AlphaService.class) 注解形式实现bean生命周期管理123456789101112131415161718@Service@Scopepublic class AlphaService &#123; public AlphaService() &#123; System.out.println(&quot;实例化AlphaService&quot;); &#125; @PostConstruct public void init()&#123; System.out.println(&quot;初始化alpahService&quot;); &#125; @PreDestroy public void destroy()&#123; System.out.println(&quot;销毁AlpahService&quot;); &#125;&#125; 系统类加入bean管理相同包下创建config文件夹 123456789@Configurationpublic class AlphaConfig &#123; @Bean public SimpleDateFormat simpleDateFormat()&#123; return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125;&#125; 其他注解注解式开发时为了简化XML配置，也可以通过xml文件进行配置，底层都是反射机制 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Indexedpublic @interface Component &#123; String value() default &quot;&quot;;&#125; @Target与@Retention为元注解，即注解的注解 @Target表示注解可以出现的位置 @Retention表示注解的策略 属性value表示注解的属性，即beanid，默认为类的首字母小写 注入的注解 @Value，注入简单类型，注入属性&#x2F;setter方法 12@Value(value = &quot;zhangsan&quot;) private String name; @Autowired，注入非简单类型，默认按照类型注入，用于属性&#x2F;setter方法&#x2F;构造方法&#x2F;构造方法参数上，@Qualifier按照名字注入 @Resource，jdk中，默认按照名字注入，没有名字则使用属性名作为名字，找不到则按类型注入","categories":[],"tags":[]},{"title":"","slug":"Apache","date":"2023-04-30T02:04:48.985Z","updated":"2023-04-30T02:04:49.085Z","comments":true,"path":"2023/04/30/Apache/","link":"","permalink":"https://wang-qing-yang.github.io/2023/04/30/Apache/","excerpt":"","text":"Apacheskywalking Doris DUBBO SeaTunnel(Incubating) RocketMQ ShardingSphere","categories":[],"tags":[]},{"title":"每日一题记录","slug":"daily","date":"2023-04-23T02:30:31.000Z","updated":"2023-04-23T14:53:43.230Z","comments":true,"path":"2023/04/23/daily/","link":"","permalink":"https://wang-qing-yang.github.io/2023/04/23/daily/","excerpt":"","text":"每日一题20230423 1105.填充书架动态规划，书按照顺序放置，dp[i]为i本书摆放的最小高度，即[0,i-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://wang-qing-yang.github.io/categories/Leetcode/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://wang-qing-yang.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"二叉树-2","slug":"2023-04-08-二叉树-2","date":"2023-04-22T02:30:31.000Z","updated":"2023-04-24T14:40:28.335Z","comments":true,"path":"2023/04/22/2023-04-08-二叉树-2/","link":"","permalink":"https://wang-qing-yang.github.io/2023/04/22/2023-04-08-%E4%BA%8C%E5%8F%89%E6%A0%91-2/","excerpt":"","text":"二叉树二叉搜索树定义 左子树的节点值均小于根节点的值 右子树的节点值均大于根节点的值 左右子树分别为二叉搜索树 重要性质中序遍历二叉搜索树得到：节点值递增的节点序列 题目530.二叉搜索树的最小绝对差最小绝对差：树中任意两不同节点的最小差值，则在搜索二叉树中为，中序遍历相邻节点的最小差值 12345678910111213141516171819202122232425//递归遍历class Solution &#123; //全局变量，记录最小值、遍历的上一个节点 int min = Integer.MAX_VALUE; TreeNode pre; public int getMinimumDifference(TreeNode root) &#123; getMin(root); return min; &#125; //中遍历二叉搜索树，则为递增的节点，逐一判断差值 public void getMin(TreeNode node)&#123; if(node == null)&#123; return; &#125; getMin(node.left); //当和前一个节点差值小于最小值，则更新最小值 if(pre != null)&#123; min = Math.min(node.val - pre.val,min); &#125; //更新节点 pre = node; getMin(node.right); return; &#125;&#125; 时间复杂度：O(N)，每个节点被访问一次 空间复杂度：O(N)，系统栈的长度为二叉树深度，在最差情况下二叉搜索树为一个链表 123456789101112131415161718192021222324252627//迭代class Solution &#123; public int getMinimumDifference(TreeNode root) &#123; //初始化栈和最小值 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); int min = Integer.MAX_VALUE; //存放当前节点与上一个节点 TreeNode cur = root; TreeNode pre = null; while(cur != null || !stack.isEmpty())&#123; //入栈直到最左边节点 if(cur != null)&#123; stack.push(cur); cur = cur.left; &#125;else&#123;//最左边节点先出栈 cur = stack.pop(); if(pre != null)&#123; min = Math.min(min, cur.val - pre.val); &#125; //更新节点 pre = cur; cur = cur.right; &#125; &#125; return min; &#125;&#125; 时间复杂度：O(N)，每个节点被访问一次 空间复杂度：O(N)，栈的空间最差情况为节点数 501.二叉搜索树中的众数中序遍历，比较相邻节点 记录节点频率与最高频率，当相等时，加入集合，大于时更新频率，清空集合 记录上一个节点，用于更新频率 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; //全局变量 //集合，存放结果 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //记录频率 int count = 0; //记录最高频率 int maxCount = 0; //记录上一个节点 TreeNode pre; public int[] findMode(TreeNode root) &#123; find(root); int[] res = new int[list.size()]; for(int i = 0; i &lt; res.length; i++)&#123; res[i] = list.get(i); &#125; return res; &#125; public void find(TreeNode node)&#123; //中序遍历 if(node == null)&#123; return; &#125; find(node.left); //节点相同，则增加 if(pre != null &amp;&amp; pre.val == node.val)&#123; count++; &#125;else&#123;//不相同，则为新节点，当前节点频率为1 count = 1; &#125; //节点频率为最高，则加入集合 if(count == maxCount)&#123; list.add(node.val); &#125; //出现更高频率，则清空集合，加入当前节点，更新最高频率 if(count &gt; maxCount)&#123; list.clear(); list.add(node.val); maxCount = count; &#125; //更新节点 pre = node; find(node.right); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//迭代class Solution &#123; public int[] findMode(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); TreeNode pre = null; TreeNode cur = root; int count = 0; int Maxcount = 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(cur != null || !stack.isEmpty())&#123; if(cur != null)&#123; stack.push(cur); cur = cur.left; &#125;else&#123; cur = stack.pop(); //根据相邻节点关系，更新频率 if(pre != null &amp;&amp; cur.val == pre.val)&#123; count++; &#125;else&#123; count = 1; &#125; //根据count，更新集合 if(count == Maxcount)&#123; list.add(cur.val); &#125; if(count &gt; Maxcount)&#123; list.clear(); list.add(cur.val); Maxcount = count; &#125; //更新节点 pre = cur; cur = cur.right; &#125; &#125; int[] res = new int[list.size()]; for(int i = 0; i&lt; res.length; i++)&#123; res[i] = list.get(i); &#125; return res; &#125;&#125; 236.二叉树的最近公共祖先从下往上遍历二叉树，则采用后序遍历 最近公共祖先则有： 节点左右子树中，分别包含两个节点，则此根节点为最佳公共祖先 节点为p，左&#x2F;右子树中含有q，则此节点为最近公共祖先 为了传递这个祖先信息，即子树中含有p&#x2F;q节点的信息，则需要返回节点，当返回节点为null则子树没有p&#x2F;q，当非null，则为p&#x2F;q&#x2F;最近公共祖先，需要继续向上传递 当左右子树的返回值都非null，则此节点为公共祖先，返回此节点 当左右节点有非null，则传递这个信息，返回这个非null 当都为Null，则没有找到，则返回Null 1234567891011121314151617181920212223242526class Solution &#123; //从下往上遍历，对每个子树返回是否找到节点 //传递信息直到根节点 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; //从下往上递归遍历二叉树，即左右中 //返回值为节点，当遇到p/q则返回p/q，表示找到节点，不是则返回null，表示没有找到 if(root == null || root == p || root == q)&#123; return root; &#125; //后序遍历 TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null &amp;&amp; right == null)&#123;//没有找到 return null; &#125;else if(left != null &amp;&amp; right != null)&#123;//左右子树分别找到，则返回祖先 return root; &#125;else if(left == null)&#123;//左子树没有找到，则返回右子树信息 return right; &#125;else&#123; return left; &#125; &#125;&#125; 235.二叉搜索树的最近公共祖先二叉搜索树，则最近公共祖先的必要条件是值在[p.val,q.val]之间，从上往下遍历，当第一次遇到这个范围的节点，即为最近公共祖先，因为此时，pq分别位于左右子树，无论继续往左或者往右遍历，都不再有公共祖先。 1234567891011121314151617181920class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; //公共祖先与两个指定节点的关系 //1.两个指定节点在公共祖先的左右子树中，此时root.val在(p.val,q.val)之间 //2.公共祖先为其中一个节点，此时root.val==p.val/q.val //从上往下，找到的第一个在[p.val,q.val]之间的值，为公共祖先 //因为继续往左右子树遍历，必定不是公共祖先 if(root == null)&#123; return null; &#125; if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123; return lowestCommonAncestor(root.left,p,q); &#125;else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123; return lowestCommonAncestor(root.right,p,q); &#125;else&#123; return root; &#125; &#125;&#125; 70","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://wang-qing-yang.github.io/categories/Leetcode/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://wang-qing-yang.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"","slug":"Spring6-day2","date":"2023-04-10T01:04:20.792Z","updated":"2023-04-10T01:04:20.862Z","comments":true,"path":"2023/04/10/Spring6-day2/","link":"","permalink":"https://wang-qing-yang.github.io/2023/04/10/Spring6-day2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Spring6-week1","slug":"Spring6-week1","date":"2023-04-09T15:49:05.000Z","updated":"2023-04-22T08:59:09.457Z","comments":true,"path":"2023/04/09/Spring6-week1/","link":"","permalink":"https://wang-qing-yang.github.io/2023/04/09/Spring6-week1/","excerpt":"","text":"Spring6问题与解决方法MVC架构web层（表示层），service层（业务层），dao（持久层） 简单依赖关系在service层，web层的实例中，先创建dao层的实例，再在方法中调用实例方法 12345678910public class UserServiceImpl implements UserService &#123; //用于调用DAO层，即持久层进行具体操作 private UserDao userDao = new UserDaoImplForMySQL(); @Override public void deleteUser() &#123; //删除用户信息的逻辑 //调用持久层 userDao.deleteById(); &#125;&#125; 则当持久层的实现类进行变换，需要在业务层修改代码 12//用于调用DAO层，即持久层进行具体操作private UserDao userDao = new UserDaoImplForOracle(); 同样当业务层的实现类进行变换，需要在表现层修改相应的创建实例的代码 导致程序耦合高，因为在层中创建下层的实例，导致上层依赖下层。 OCP开闭原则不符合OCP开闭原则：软件开发中应当对扩展开放，对修改关闭。因为修改之前正常的程序，则需要对各个修改的部分进行重新测试上线，成本高，复杂度高。 （软件七大开发原则，其他六原则为OCP服务） 依赖倒置原则（DIP原则）Dependence Inversion principle，面向抽象编程，面向接口编程，上层不依赖下层 解决方法12345678910public class UserServiceImpl implements UserService &#123; //依赖倒置 private UserDao userDao； @Override public void deleteUser() &#123; //不再是具体的实现类 userDao.deleteById(); &#125;&#125;//如何创建对象？如何将对象赋值到UserDao 控制反转 IoC(Inversion of Control)Spring框架，帮助创建对象(选择接口对应的实现类)，维护对象之间关系（即怎样选择实例），并对象赋到属性中（实例赋值给接口对象）。将创建对象，new对象，即实例化的工作交给spring做，称为控制反转（Inversion of Control）。 IoC：面向对象编程的一种设计思想，将对象的创建权交出去，将对象与对象之间关系的管理权交出去，由第三方容器负责创建与维护。 实现方式：依赖注入（Dependency Injection, DI） DI实现方式：set方法注入&#x2F;构造方法注入—–方法中给属性赋值 Spring框架：一个实现了IoC思想的框架 Spring概要Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。 八大模块 创建Spring程序配置依赖通过maven配置pom.xml依赖，引入spring context依赖与测试junit 12345678910111213141516171819202122232425&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;repository.spring.milestone&lt;/id&gt; &lt;name&gt;Spring Milestone Repository&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit，用于测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 同时会自动引入： spring aop：面向切面编程 spring beans：IoC核心 spring core：spring的核心工具包 spring jcl：spring的日志包 spring expression：spring表达式 编写配置文件类的根路径下：resource下创建spring.xml文件，用于配置bean 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--id:对象的唯一标识，class:对象的类名，为全限定类名--&gt; &lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.spring6.bean.User&quot;/&gt;&lt;/beans&gt; 测试程序在test&#x2F;java下编写测试程序，添加junit单元测试@test 12345678910111213141516171819202122package com.powernode.spring6.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Spring6Test &#123; @Test public void testFirst()&#123; // 根据类目录下的xml文件初始化Spring容器上下文，此时完成 // 1.解析beans.xml文件 // 2.创建所有的bean对象 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); // 根据id获取bean对象 Object userBean = applicationContext.getBean(&quot;userBean&quot;); System.out.println(userBean); //可以指定类，向下转型 User userBean = applicationContext.getBean(&quot;userBean&quot;，User.class); System.out.println(userBean); &#125;&#125; 构建 ApplicationContext主要的方法： ClassPathXmlApplicationContext():类路径下的xml文件，resource目录 FileSystemXmlApplicationContext()：系统路径下的xml文件 AnnotationConfigApplicationContext():注释配置 创建ApplicationContext过程中： 创建实例bean 向各个bean中注入依赖 程序细节 bean标签的id属性不可重复，唯一标识bean 底层创建对象：通过反射机制调用无参构造方法 1234// dom4j解析beans.xml文件，从中获取class的全限定类名// 通过反射机制调用无参数构造方法创建对象Class clazz = Class.forName(&quot;com.powernode.spring6.bean.User&quot;);Object obj = clazz.newInstance(); 创建对象的存储方式：Map&lt;String,Object&gt;，哈希表存储id与对象 bean配置文件，命名不重要，可以多个文件，同时进行spring容器初始化，可以配置任意类bean，只要不是抽象且提供了无参构造方法 BeanFactory是spring容器的超级父类 Log4j2日志框架，引入依赖，配置文件log4j2.xml IoC实现IoC控制反转一种面向对象的设计思想 目的：降低程序耦合，提高扩展能力，达到OCP和DIP原则 具体反转： 对象的创建，交给第三方容器实现 对象和对象之间关系的维护，交给第三方容器负责 实现方式：依赖注入（DI）（Dependency Injection），通过xml文件配置bean&#x2F;SpringBoot注释配置 DI依赖注入通过依赖注入实现控制反转的思想，Spring通过依赖注入完成bean管理：bean对象的创建&#x2F;属性赋值 让对象与对象之间产生关系，常用方式： set注入 构造注入 set注入底层通过反射机制调用属性对应的set方法给属性赋值，要求必须提供set方法 12345678910111213public class UserService &#123; private UserDao userDao; // 使用set方式注入，必须提供set方法，set方法名很重要 // 反射机制要调用这个方法给属性赋值的。 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void save()&#123; userDao.insert(); &#125;&#125; 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userDaoBean&quot; class=&quot;com.powernode.spring6.dao.UserDao&quot;/&gt; &lt;bean id=&quot;userServiceBean&quot; class=&quot;com.powernode.spring6.service.UserService&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoBean&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; property标签中，获得属性名，推断set方法名为setUserDao，通过反射获得属性的set方法，根据ref中的id将userDaoBean赋值给属性 注入外部Bean注入内部Bean注入简单类型12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userBean&quot; class=&quot;com.powernode.spring6.beans.User&quot;&gt; &lt;!--简单类型注入的时候要使用value属性，不能使用ref--&gt; &lt;!--&lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;--&gt; &lt;property name=&quot;age&quot; value=:&quot;1&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 简单类型： 基本数据类型 基本数据类型对应的包装类 String或其他的CharSequence子类 Number子类 Date子类 Enum子类 URI URL Temporal子类 Locale Class 另外还包括以上简单值类型对应的数组类型。 url会进行有效性检测，Date日期格式有特定要求 级联属性赋值注入数组&#x2F;List集合&#x2F;Set集合&#x2F;Map集合&#x2F;Properties&#x2F;null&#x2F;空字符串&#x2F;特殊符号构造注入底层通过反射机制调用构造方法给属性赋值，注意：则创建对象与属性赋值同时完成 123456789101112public class OrderService &#123; private OrderDao orderDao; // 通过反射机制调用构造方法给属性赋值 public OrderService(OrderDao orderDao) &#123; this.orderDao = orderDao; &#125; public void delete()&#123; orderDao.deleteById(); &#125;&#125; 12345&lt;bean id=&quot;orderDaoBean&quot; class=&quot;com.powernode.spring6.dao.OrderDao&quot;/&gt;&lt;bean id=&quot;orderServiceBean&quot; class=&quot;com.powernode.spring6.service.OrderService&quot;&gt; &lt;!--index=&quot;0&quot;表示构造方法的第一个参数，将orderDaoBean对象传递给构造方法的第一个参数。--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;orderDaoBean&quot;/&gt;&lt;/bean&gt; xml文件通过：下标&#x2F;参数名&#x2F;类型 推断参数装配 p命名空间注入简化配置，set xml文件添加：xmlns:p&#x3D;”http://www.springframework.org/schema/p“ 基于setter方法 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;customerBean&quot; class=&quot;com.powernode.spring6.beans.Customer&quot; p:name=&quot;zhangsan&quot; p:age=&quot;20&quot;/&gt;&lt;/beans&gt; c命名空间注入简化配置，构造方法 xmlns:c&#x3D;”http://www.springframework.org/schema/c“ 构造方法 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--&lt;bean id=&quot;myTimeBean&quot; class=&quot;com.powernode.spring6.beans.MyTime&quot; c:year=&quot;1970&quot; c:month=&quot;1&quot; c:day=&quot;1&quot;/&gt;--&gt; &lt;bean id=&quot;myTimeBean&quot; class=&quot;com.powernode.spring6.beans.MyTime&quot; c:_0=&quot;2008&quot; c:_1=&quot;8&quot; c:_2=&quot;8&quot;/&gt;&lt;/beans&gt; util命名空间注入配置复用 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;util:properties id=&quot;prop&quot;&gt; &lt;prop key=&quot;driver&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;url&quot;&gt;jdbc:mysql://localhost:3306/spring&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt; &lt;/util:properties&gt; &lt;bean id=&quot;dataSource1&quot; class=&quot;com.powernode.spring6.beans.MyDataSource1&quot;&gt; &lt;property name=&quot;properties&quot; ref=&quot;prop&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource2&quot; class=&quot;com.powernode.spring6.beans.MyDataSource2&quot;&gt; &lt;property name=&quot;properties&quot; ref=&quot;prop&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 自动装配根据名字12345678910111213public class UserService &#123; private UserDao aaa; // 这个set方法非常关键 public void setAaa(UserDao aaa) &#123; this.aaa = aaa; &#125; public void save()&#123; aaa.insert(); &#125;&#125; 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.powernode.spring6.service.UserService&quot; autowire=&quot;byName&quot;/&gt; &lt;!--根据set名格式，命名bean--&gt; &lt;bean id=&quot;aaa&quot; class=&quot;com.powernode.spring6.dao.UserDao&quot;/&gt;&lt;/beans&gt; 根据类型注入外部属性配置文件类路径下创建properties文件，xml文件中引入context命名空间，配置properties文件","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://wang-qing-yang.github.io/categories/Spring6/"}],"tags":[{"name":"OCP","slug":"OCP","permalink":"https://wang-qing-yang.github.io/tags/OCP/"},{"name":"DIP","slug":"DIP","permalink":"https://wang-qing-yang.github.io/tags/DIP/"},{"name":"IoC","slug":"IoC","permalink":"https://wang-qing-yang.github.io/tags/IoC/"},{"name":"DI","slug":"DI","permalink":"https://wang-qing-yang.github.io/tags/DI/"},{"name":"AOP","slug":"AOP","permalink":"https://wang-qing-yang.github.io/tags/AOP/"}]},{"title":"resemu","slug":"resemu","date":"2023-04-08T08:26:59.000Z","updated":"2023-04-08T08:29:07.838Z","comments":true,"path":"2023/04/08/resemu/","link":"","permalink":"https://wang-qing-yang.github.io/2023/04/08/resemu/","excerpt":"","text":"王庆阳 电话：13696566641 | 邮箱：qywang2021@163.com | 博客：https://wangqingyang.github.io 年龄：23 | 性别：男 求职意向：后端开发工程师 教育背景2022.09 - 2025.06 东南大学 控制科学与工程专业 硕士 2018.09 - 2022.06 合肥工业大学大学 自动化专业 本科 专业技能 熟练掌握 Java语言，熟悉多线程、集合框架、JVM等相关知识； 熟练使用Spring Cloud、Spring Boot、MyBatis等常用框架，熟悉Spring IOC、AOP原理，了解Nacos、Spring Cloud Gateway等组件； 熟练使用MySQL，熟悉MySQL索引、事务、锁机制、日志系统、数据备份与恢复； 深入理解Redis数据类型使用场景和内部实现，熟悉持久化和淘汰策略，熟悉缓存高并发场景； 了解Kafka、Elasticsearch的使用，熟悉Kafka基本结构、消费者组、备份机制的原理，熟悉 Elasticsearch倒排索引的原理。 项目经历2019.10 - 2020.01 社区论坛 全栈开发工程师 项目简介： 该论坛是一个互动交流平台，实现了注册登录、发帖评论、回复点赞、消息提醒、内容搜索和网站数据统计的功能，并将用户头像等信息存于七牛云。 项目地址：演示地址: www.coolsen.cn Github: https://github.com/cosen1024/community 技术栈：Spring Boot + MyBatis + MySQL + Redis + Kafka + Elasticsearch 工作内容： 使用Redis存储登录ticket和验证码，解决分布式session问题； 使用Redis的set实现点赞，zset实现关注，HyperLogLog统计UV，Bitmap统计DAU； 使用Kafka处理发送评论、点赞和关注等系统通知，起到解耦和异步调用的作用； 使用Elasticsearch对帖子搜索功能进行重构，通过IK中文分词器增加增量索引和全局索引，实现搜索关键词高亮显示等功能； 对热帖排行模块，使用分布式缓存Redis和本地缓存Caffeine作为多级缓存，将QPS提升了20倍（10-200），大大提升了网站访问速度，并使用Quartz定时更新热帖排行榜。 个人荣誉","categories":[{"name":"个人","slug":"个人","permalink":"https://wang-qing-yang.github.io/categories/%E4%B8%AA%E4%BA%BA/"}],"tags":[{"name":"简历","slug":"简历","permalink":"https://wang-qing-yang.github.io/tags/%E7%AE%80%E5%8E%86/"}]},{"title":"二叉树-1","slug":"二叉树-1","date":"2023-04-08T02:30:31.000Z","updated":"2023-04-08T07:56:08.935Z","comments":true,"path":"2023/04/08/二叉树-1/","link":"","permalink":"https://wang-qing-yang.github.io/2023/04/08/%E4%BA%8C%E5%8F%89%E6%A0%91-1/","excerpt":"","text":"二叉树定义1234567891011121314151617public class TreeNode&#123; int val; TreeNode left; TreeNode right; TreeNode()&#123;&#125; TreeNode(int val)&#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right)&#123; this.val = val; this.left = left; this.right = right; &#125;&#125; 遍历​ 二叉树遍历，即按照某种方式，依照某种顺序访问二叉树的所有节点，可以理解为对二叉树的各个子树进行遍历，子树与节点的概念在大多数情况下是相同的，因为每个节点都可以当作一个子树，或者说取得一个节点，则可以获得这个节点为根节点的子树 遍历目的对二叉树的各个节点的访问，能够全面的分析二叉树，因为二叉树由且仅由一个个节点组成 二叉树的结构，具体有： 判断二叉树结构特性 修改二叉树结构，重构二叉树 二叉树的属性 取出符合条件的节点（节点个数&#x2F;左叶子之和&#x2F;数左下角的值 比较各个节点 二叉搜索树属性 二叉树公共祖先 二叉搜索树结构 遍历方式二叉树遍历&#x3D;遍历节点&#x3D;遍历子树 按照遍历方法有：递归遍历与迭代遍历 按照遍历顺序有：前序遍历，中序遍历，后序遍历，层序遍历 DFS(深度优先遍历)：前序遍历，中序遍历，后序遍历 BFS(广度优先遍历)：层序遍历 递归遍历递归写法： 确定递归函数的参数与返回值：参数往往是节点，返回值往往是题干所需值 确定终止条件，递归实际上是利用系统栈存储节点信息，需要终止条件防止栈溢出(stack overflow)，终止条件往往是null节点，或者叶子节点，返回相应的返回值 确定单层递归逻辑，确定每次递归中对节点&#x2F;节点左子树&#x2F;节点右子树的处理顺序，以及对节点的具体操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//前序遍历，中-&gt;左-&gt;右，即先取出根节点，再遍历左子树，最后遍历右子树class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); preOrder(list,root); return list; &#125; //递归，输入参数为节点，集合，不需要返回值 public void preOrder(List&lt;Integer&gt; list, TreeNode node)&#123; //终止条件，当节点为null，此时不存在节点，则不需要加入集合，直接返回 if(node == null)&#123; return; &#125; //单层逻辑，前序遍历，先将节点值放入集合，再遍历左右子树 list.add(node.val); preOrder(list,node.left); preOrder(list,node.right); return; &#125;&#125;//中序遍历，左-&gt;中-&gt;右，即先遍历左子树，再取出根节点，最后遍历右子树//需要注意的是：第一个取出的节点仍为根节点，但是最左侧子树的根节点，正如前面所说，节点即为子树//即为左叶子节点 public void preOrder(List&lt;Integer&gt; list, TreeNode node)&#123; //终止条件，当节点为null，此时不存在节点，则不需要加入集合，直接返回 if(node == null)&#123; return; &#125; //单层逻辑，中序遍历，先遍历左子树，再取出根节点，最后遍历右子树 preOrder(list,node.left); list.add(node.val); preOrder(list,node.right); return; &#125;//后序遍历，左-&gt;右-&gt;中，即先遍历左子树，再遍历右子树，最后取出根节点 public void preOrder(List&lt;Integer&gt; list, TreeNode node)&#123; //终止条件，当节点为null，此时不存在节点，则不需要加入集合，直接返回 if(node == null)&#123; return; &#125; //单层逻辑，中序遍历，先遍历左子树，再遍历右子树，最后取出根节点 preOrder(list,node.left); preOrder(list,node.right); list.add(node.val); return; &#125; 层序遍历具有特殊性，利用先进先出的队列模拟系统栈，将每一层的节点加入栈进行遍历 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; //层序遍历，使用先进先出的队列 Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //先将第一层，即根节点加入 if(root != null)&#123; que.offer(root); &#125; //进行层序遍历 while(!que.isEmpty())&#123; //记录当前层的节点个数 int size = que.size(); //存放当前层的节点 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //遍历层中节点 for(int i = 0; i &lt; size; i++)&#123; TreeNode cur = que.poll(); list.add(cur.val); //加入下一层到队列 if(cur.left != null)&#123; que.offer(cur.left); &#125; if(cur.right != null)&#123; que.offer(cur.right); &#125; &#125; //当前层节点加入集合 res.add(list); &#125; return res; &#125;&#125; 迭代遍历迭代，则需要创建stack模拟系统栈，栈为先进后出，则控制入栈顺序就可以确定出栈顺序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//前序迭代，遍历顺序为中左右，则入栈顺序为右左class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; //迭代法，则用栈模拟递归的系统栈 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); //先加入根节点到栈 if(root != null)&#123; stack.push(root); &#125; while(!stack.isEmpty())&#123; TreeNode cur = stack.pop(); list.add(cur.val); //先加入右节点，再加入左节点 if(cur.right != null)&#123; stack.push(cur.right); &#125; if(cur.left != null)&#123; stack.push(cur.left); &#125; &#125; return list; &#125;&#125;//后序迭代，即左右中，反转即为中右左，则进行中右左遍历，最后反转即可class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null)&#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode cur = stack.pop(); list.add(cur.val); //入栈为左右 if(cur.left != null)&#123; stack.push(cur.left); &#125; if(cur.right != null)&#123; stack.push(cur.right); &#125; &#125; //反转 Collections.reverse(list); return list; &#125;&#125;//中序迭代，左中右，比较特殊，因为访问节点的顺序与处理元素顺序不同//需要注意：最左叶子节点=最左子树根节点class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null)&#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; //当当前节点为null，且栈空，则此时已经遍历完全 while(cur != null || !stack.isEmpty())&#123; //递归加入节点到栈，直到最左叶子节点，即最左子树的根节点 if(cur != null)&#123; stack.push(cur); cur = cur.left; &#125;else&#123;//节点为空，则栈顶元素为最左子树根节点，弹出并判断其右子树 cur = stack.pop(); list.add(cur.val); cur = cur.right; &#125; &#125; return list; &#125;&#125; 莫里斯遍历​ 没有辅助空间，改变了树的结构 总结遍历方式中，递归与迭代实现效果相同，仅在代码层面不同，优先选择递归，所有可选的遍历方式实际上仅有：前序&#x2F;中序&#x2F;后序递归&#x2F;层序遍历 解题 按照遍历目的进行分类： 二叉树属性：取出符合条件的节点 分析条件，确定判断方式 选择遍历方式 404.左叶子之和题干：给定二叉树的根节点 root ，返回所有左叶子之和。 明确条件，左叶子的判断：通过单个节点无法判断其是否为左叶子，需要通过父节点判断，具体判断为 123if(root.left != null &amp;&amp; root.left.left == null &amp;&amp;root.left.right == null)&#123; //root.left为符合条件的左叶子&#125; 选择遍历方式，即对每个子树取得左叶子节点，进行累加，选择任何遍历方式都可以，此处选择后序遍历 123456789101112131415161718192021class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; //遍历每棵子树，累加左叶子结点值 //终止条件，当为null，则返回0 if(root == null)&#123; return 0; &#125; if(root.left == null &amp;&amp; root.right == null)&#123; return 0; &#125; int mid = 0; //判断左节点是否为左叶子 if(root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null)&#123; mid = root.left.val; &#125; int right = sumOfLeftLeaves(root.right); int left = sumOfLeftLeaves(root.left); return mid + left + right; &#125;&#125; 513.找树左下角的值题干：找最底层最左边节点的值 明确条件，最底层最左边的值，即层数最大的叶子节点，即遍历中遇到层数最大的第一个节点 BFS&#x2F;DFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//层序遍历，每一层的一个节点，即队列中的第一个元素class Solution &#123; public int findBottomLeftValue(TreeNode root) &#123; //层序遍历 Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;(); que.offer(root); //初始化结果为根节点值 int res = root.val; while(!que.isEmpty())&#123; int size = que.size(); //每层第一个元素即为最左节点 res = que.peek().val; for(int i = 0; i &lt; size; i++)&#123; TreeNode node = que.poll(); if(node.left != null)&#123; que.offer(node.left); &#125; if(node.right != null)&#123; que.offer(node.right); &#125; &#125; &#125; return res; &#125;&#125;//DFS，深度优先遍历，每次优先遍历当前节点左子树，则当第一次搜索到最大深度，即为最左节点class Solution &#123; //全局遍历，记录节点值与深度 int res; int maxDepth; public int findBottomLeftValue(TreeNode root) &#123; getLeft(root,1); return res; &#125; //遍历 public void getLeft(TreeNode node, int depth)&#123; if(node == null)&#123; return; &#125; //第一次遇到深度&gt;，则存储节点 if(depth &gt; maxDepth)&#123; res = node.val; maxDepth = depth; &#125; //左右遍历 getLeft(node.left,depth+1); getLeft(node.right,depth+1); return; &#125;&#125; 112.路径总和判断树中是否存在根节点到叶子节点的路径和&#x3D;目标值 不需要遍历整棵树，需要有返回值 遍历需要存储路径和，即参数为节点与路径和 113.路径总和2","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://wang-qing-yang.github.io/categories/Leetcode/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://wang-qing-yang.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://wang-qing-yang.github.io/categories/Leetcode/"},{"name":"Spring6","slug":"Spring6","permalink":"https://wang-qing-yang.github.io/categories/Spring6/"},{"name":"个人","slug":"个人","permalink":"https://wang-qing-yang.github.io/categories/%E4%B8%AA%E4%BA%BA/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://wang-qing-yang.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://wang-qing-yang.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"OCP","slug":"OCP","permalink":"https://wang-qing-yang.github.io/tags/OCP/"},{"name":"DIP","slug":"DIP","permalink":"https://wang-qing-yang.github.io/tags/DIP/"},{"name":"IoC","slug":"IoC","permalink":"https://wang-qing-yang.github.io/tags/IoC/"},{"name":"DI","slug":"DI","permalink":"https://wang-qing-yang.github.io/tags/DI/"},{"name":"AOP","slug":"AOP","permalink":"https://wang-qing-yang.github.io/tags/AOP/"},{"name":"简历","slug":"简历","permalink":"https://wang-qing-yang.github.io/tags/%E7%AE%80%E5%8E%86/"}]}