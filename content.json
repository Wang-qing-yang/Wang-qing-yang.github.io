{"meta":{"title":"wangqingyang-demo","subtitle":"blog-demo","description":"testonly","author":"wang","url":"https://wang-qing-yang.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-04-08T07:32:44.299Z","updated":"2023-04-08T06:55:52.720Z","comments":false,"path":"/404.html","permalink":"https://wang-qing-yang.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-04-08T07:57:50.639Z","updated":"2023-04-08T06:55:52.722Z","comments":false,"path":"about/index.html","permalink":"https://wang-qing-yang.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2023-04-08T06:55:52.723Z","updated":"2023-04-08T06:55:52.723Z","comments":false,"path":"books/index.html","permalink":"https://wang-qing-yang.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-04-08T06:55:52.725Z","updated":"2023-04-08T06:55:52.725Z","comments":false,"path":"tags/index.html","permalink":"https://wang-qing-yang.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-04-08T07:32:54.749Z","updated":"2023-04-08T06:55:52.723Z","comments":false,"path":"categories/index.html","permalink":"https://wang-qing-yang.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"resemu","slug":"resemu","date":"2023-04-08T08:26:59.000Z","updated":"2023-04-08T08:29:07.838Z","comments":true,"path":"2023/04/08/resemu/","link":"","permalink":"https://wang-qing-yang.github.io/2023/04/08/resemu/","excerpt":"","text":"王庆阳 电话：13696566641 | 邮箱：qywang2021@163.com | 博客：https://wangqingyang.github.io 年龄：23 | 性别：男 求职意向：后端开发工程师 教育背景2022.09 - 2025.06 东南大学 控制科学与工程专业 硕士 2018.09 - 2022.06 合肥工业大学大学 自动化专业 本科 专业技能 熟练掌握 Java语言，熟悉多线程、集合框架、JVM等相关知识； 熟练使用Spring Cloud、Spring Boot、MyBatis等常用框架，熟悉Spring IOC、AOP原理，了解Nacos、Spring Cloud Gateway等组件； 熟练使用MySQL，熟悉MySQL索引、事务、锁机制、日志系统、数据备份与恢复； 深入理解Redis数据类型使用场景和内部实现，熟悉持久化和淘汰策略，熟悉缓存高并发场景； 了解Kafka、Elasticsearch的使用，熟悉Kafka基本结构、消费者组、备份机制的原理，熟悉 Elasticsearch倒排索引的原理。 项目经历2019.10 - 2020.01 社区论坛 全栈开发工程师 项目简介： 该论坛是一个互动交流平台，实现了注册登录、发帖评论、回复点赞、消息提醒、内容搜索和网站数据统计的功能，并将用户头像等信息存于七牛云。 项目地址：演示地址: www.coolsen.cn Github: https://github.com/cosen1024/community 技术栈：Spring Boot + MyBatis + MySQL + Redis + Kafka + Elasticsearch 工作内容： 使用Redis存储登录ticket和验证码，解决分布式session问题； 使用Redis的set实现点赞，zset实现关注，HyperLogLog统计UV，Bitmap统计DAU； 使用Kafka处理发送评论、点赞和关注等系统通知，起到解耦和异步调用的作用； 使用Elasticsearch对帖子搜索功能进行重构，通过IK中文分词器增加增量索引和全局索引，实现搜索关键词高亮显示等功能； 对热帖排行模块，使用分布式缓存Redis和本地缓存Caffeine作为多级缓存，将QPS提升了20倍（10-200），大大提升了网站访问速度，并使用Quartz定时更新热帖排行榜。 个人荣誉","categories":[{"name":"个人","slug":"个人","permalink":"https://wang-qing-yang.github.io/categories/%E4%B8%AA%E4%BA%BA/"}],"tags":[{"name":"简历","slug":"简历","permalink":"https://wang-qing-yang.github.io/tags/%E7%AE%80%E5%8E%86/"}]},{"title":"二叉树-1","slug":"二叉树-1","date":"2023-04-08T02:30:31.000Z","updated":"2023-04-08T07:56:08.935Z","comments":true,"path":"2023/04/08/二叉树-1/","link":"","permalink":"https://wang-qing-yang.github.io/2023/04/08/%E4%BA%8C%E5%8F%89%E6%A0%91-1/","excerpt":"","text":"二叉树定义1234567891011121314151617public class TreeNode&#123; int val; TreeNode left; TreeNode right; TreeNode()&#123;&#125; TreeNode(int val)&#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right)&#123; this.val = val; this.left = left; this.right = right; &#125;&#125; 遍历​ 二叉树遍历，即按照某种方式，依照某种顺序访问二叉树的所有节点，可以理解为对二叉树的各个子树进行遍历，子树与节点的概念在大多数情况下是相同的，因为每个节点都可以当作一个子树，或者说取得一个节点，则可以获得这个节点为根节点的子树 遍历目的对二叉树的各个节点的访问，能够全面的分析二叉树，因为二叉树由且仅由一个个节点组成 二叉树的结构，具体有： 判断二叉树结构特性 修改二叉树结构，重构二叉树 二叉树的属性 取出符合条件的节点（节点个数&#x2F;左叶子之和&#x2F;数左下角的值 比较各个节点 二叉搜索树属性 二叉树公共祖先 二叉搜索树结构 遍历方式二叉树遍历&#x3D;遍历节点&#x3D;遍历子树 按照遍历方法有：递归遍历与迭代遍历 按照遍历顺序有：前序遍历，中序遍历，后序遍历，层序遍历 DFS(深度优先遍历)：前序遍历，中序遍历，后序遍历 BFS(广度优先遍历)：层序遍历 递归遍历递归写法： 确定递归函数的参数与返回值：参数往往是节点，返回值往往是题干所需值 确定终止条件，递归实际上是利用系统栈存储节点信息，需要终止条件防止栈溢出(stack overflow)，终止条件往往是null节点，或者叶子节点，返回相应的返回值 确定单层递归逻辑，确定每次递归中对节点&#x2F;节点左子树&#x2F;节点右子树的处理顺序，以及对节点的具体操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//前序遍历，中-&gt;左-&gt;右，即先取出根节点，再遍历左子树，最后遍历右子树class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); preOrder(list,root); return list; &#125; //递归，输入参数为节点，集合，不需要返回值 public void preOrder(List&lt;Integer&gt; list, TreeNode node)&#123; //终止条件，当节点为null，此时不存在节点，则不需要加入集合，直接返回 if(node == null)&#123; return; &#125; //单层逻辑，前序遍历，先将节点值放入集合，再遍历左右子树 list.add(node.val); preOrder(list,node.left); preOrder(list,node.right); return; &#125;&#125;//中序遍历，左-&gt;中-&gt;右，即先遍历左子树，再取出根节点，最后遍历右子树//需要注意的是：第一个取出的节点仍为根节点，但是最左侧子树的根节点，正如前面所说，节点即为子树//即为左叶子节点 public void preOrder(List&lt;Integer&gt; list, TreeNode node)&#123; //终止条件，当节点为null，此时不存在节点，则不需要加入集合，直接返回 if(node == null)&#123; return; &#125; //单层逻辑，中序遍历，先遍历左子树，再取出根节点，最后遍历右子树 preOrder(list,node.left); list.add(node.val); preOrder(list,node.right); return; &#125;//后序遍历，左-&gt;右-&gt;中，即先遍历左子树，再遍历右子树，最后取出根节点 public void preOrder(List&lt;Integer&gt; list, TreeNode node)&#123; //终止条件，当节点为null，此时不存在节点，则不需要加入集合，直接返回 if(node == null)&#123; return; &#125; //单层逻辑，中序遍历，先遍历左子树，再遍历右子树，最后取出根节点 preOrder(list,node.left); preOrder(list,node.right); list.add(node.val); return; &#125; 层序遍历具有特殊性，利用先进先出的队列模拟系统栈，将每一层的节点加入栈进行遍历 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; //层序遍历，使用先进先出的队列 Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //先将第一层，即根节点加入 if(root != null)&#123; que.offer(root); &#125; //进行层序遍历 while(!que.isEmpty())&#123; //记录当前层的节点个数 int size = que.size(); //存放当前层的节点 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //遍历层中节点 for(int i = 0; i &lt; size; i++)&#123; TreeNode cur = que.poll(); list.add(cur.val); //加入下一层到队列 if(cur.left != null)&#123; que.offer(cur.left); &#125; if(cur.right != null)&#123; que.offer(cur.right); &#125; &#125; //当前层节点加入集合 res.add(list); &#125; return res; &#125;&#125; 迭代遍历迭代，则需要创建stack模拟系统栈，栈为先进后出，则控制入栈顺序就可以确定出栈顺序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//前序迭代，遍历顺序为中左右，则入栈顺序为右左class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; //迭代法，则用栈模拟递归的系统栈 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); //先加入根节点到栈 if(root != null)&#123; stack.push(root); &#125; while(!stack.isEmpty())&#123; TreeNode cur = stack.pop(); list.add(cur.val); //先加入右节点，再加入左节点 if(cur.right != null)&#123; stack.push(cur.right); &#125; if(cur.left != null)&#123; stack.push(cur.left); &#125; &#125; return list; &#125;&#125;//后序迭代，即左右中，反转即为中右左，则进行中右左遍历，最后反转即可class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null)&#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode cur = stack.pop(); list.add(cur.val); //入栈为左右 if(cur.left != null)&#123; stack.push(cur.left); &#125; if(cur.right != null)&#123; stack.push(cur.right); &#125; &#125; //反转 Collections.reverse(list); return list; &#125;&#125;//中序迭代，左中右，比较特殊，因为访问节点的顺序与处理元素顺序不同//需要注意：最左叶子节点=最左子树根节点class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null)&#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; //当当前节点为null，且栈空，则此时已经遍历完全 while(cur != null || !stack.isEmpty())&#123; //递归加入节点到栈，直到最左叶子节点，即最左子树的根节点 if(cur != null)&#123; stack.push(cur); cur = cur.left; &#125;else&#123;//节点为空，则栈顶元素为最左子树根节点，弹出并判断其右子树 cur = stack.pop(); list.add(cur.val); cur = cur.right; &#125; &#125; return list; &#125;&#125; 莫里斯遍历​ 没有辅助空间，改变了树的结构 总结遍历方式中，递归与迭代实现效果相同，仅在代码层面不同，优先选择递归，所有可选的遍历方式实际上仅有：前序&#x2F;中序&#x2F;后序递归&#x2F;层序遍历 解题 按照遍历目的进行分类： 二叉树属性：取出符合条件的节点 分析条件，确定判断方式 选择遍历方式 404.左叶子之和题干：给定二叉树的根节点 root ，返回所有左叶子之和。 明确条件，左叶子的判断：通过单个节点无法判断其是否为左叶子，需要通过父节点判断，具体判断为 123if(root.left != null &amp;&amp; root.left.left == null &amp;&amp;root.left.right == null)&#123; //root.left为符合条件的左叶子&#125; 选择遍历方式，即对每个子树取得左叶子节点，进行累加，选择任何遍历方式都可以，此处选择后序遍历 123456789101112131415161718192021class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; //遍历每棵子树，累加左叶子结点值 //终止条件，当为null，则返回0 if(root == null)&#123; return 0; &#125; if(root.left == null &amp;&amp; root.right == null)&#123; return 0; &#125; int mid = 0; //判断左节点是否为左叶子 if(root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null)&#123; mid = root.left.val; &#125; int right = sumOfLeftLeaves(root.right); int left = sumOfLeftLeaves(root.left); return mid + left + right; &#125;&#125; 513.找树左下角的值题干：找最底层最左边节点的值 明确条件，最底层最左边的值，即层数最大的叶子节点，即遍历中遇到层数最大的第一个节点 BFS&#x2F;DFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//层序遍历，每一层的一个节点，即队列中的第一个元素class Solution &#123; public int findBottomLeftValue(TreeNode root) &#123; //层序遍历 Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;(); que.offer(root); //初始化结果为根节点值 int res = root.val; while(!que.isEmpty())&#123; int size = que.size(); //每层第一个元素即为最左节点 res = que.peek().val; for(int i = 0; i &lt; size; i++)&#123; TreeNode node = que.poll(); if(node.left != null)&#123; que.offer(node.left); &#125; if(node.right != null)&#123; que.offer(node.right); &#125; &#125; &#125; return res; &#125;&#125;//DFS，深度优先遍历，每次优先遍历当前节点左子树，则当第一次搜索到最大深度，即为最左节点class Solution &#123; //全局遍历，记录节点值与深度 int res; int maxDepth; public int findBottomLeftValue(TreeNode root) &#123; getLeft(root,1); return res; &#125; //遍历 public void getLeft(TreeNode node, int depth)&#123; if(node == null)&#123; return; &#125; //第一次遇到深度&gt;，则存储节点 if(depth &gt; maxDepth)&#123; res = node.val; maxDepth = depth; &#125; //左右遍历 getLeft(node.left,depth+1); getLeft(node.right,depth+1); return; &#125;&#125; 112.路径总和判断树中是否存在根节点到叶子节点的路径和&#x3D;目标值 不需要遍历整棵树，需要有返回值 遍历需要存储路径和，即参数为节点与路径和 113.路径总和2","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://wang-qing-yang.github.io/categories/Leetcode/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://wang-qing-yang.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]}],"categories":[{"name":"个人","slug":"个人","permalink":"https://wang-qing-yang.github.io/categories/%E4%B8%AA%E4%BA%BA/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://wang-qing-yang.github.io/categories/Leetcode/"}],"tags":[{"name":"简历","slug":"简历","permalink":"https://wang-qing-yang.github.io/tags/%E7%AE%80%E5%8E%86/"},{"name":"二叉树","slug":"二叉树","permalink":"https://wang-qing-yang.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]}